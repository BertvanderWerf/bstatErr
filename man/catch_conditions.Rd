% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/catch_conditions.R
\name{catch_conditions}
\alias{catch_conditions}
\title{Evaluate an Expression and Capture Condition Objects}
\usage{
catch_conditions(expr, default = NULL)
}
\arguments{
\item{expr}{Expression to evaluate (enclosed in braces or as a call).}

\item{default}{Value to return if an error occurs. Default: \code{NULL}.}
}
\value{
A list with elements:
\itemize{
\item \code{value}: The evaluation result or the \code{default} if error occurred
\item \code{error}: Error condition object (or NULL if none)
\item \code{warning}: List of warning condition objects (or NULL if none)
\item \code{message}: List of message condition objects (or NULL if none)
}
}
\description{
Evaluates an expression while capturing and returning any warning, message,
or error conditions as structured objects. This allows advanced inspection of
errors and warnings instead of storing only their messages.
}
\details{
This function uses R's condition handling system to capture three types of
conditions:
\itemize{
\item \strong{Errors} (class inherits from "error"): Stops execution
\item \strong{Warnings} (class inherits from "warning"): Non-fatal issues
\item \strong{Messages} (class inherits from "message"): Informational output
}

Unlike \code{tryCatch()}, this captures the condition \emph{objects} themselves,
which include:
\itemize{
\item The message text
\item The call that generated it
\item The condition class
\item Any custom fields
}

Multiple warnings and messages are collected in a list.
}
\examples{
# Normal evaluation with no conditions
result <- catch_conditions({ 2 + 2 })
print(result$value)  # 4

# Capture warnings
result <- catch_conditions({
  x <- c(1, 2, NA)
  mean(x)
})

# Capture error with default value
result <- catch_conditions({
  stop("Something went wrong!")
}, default = NA)
print(result$error$message)

}
