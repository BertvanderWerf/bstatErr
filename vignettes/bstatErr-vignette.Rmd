---
title: "Getting Started with bstatErr"
author: "Bert van der Werf"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with bstatErr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = TRUE
)
library(bstatErr)
```

# Introduction

The `bstatErr` package provides comprehensive input validation functions for R packages. Writing robust validation code for every function can be tedious and error-prone. bstatErr simplifies this by providing ready-to-use validation functions with consistent error messages.

## Why Use bstatErr?

**Without bstatErr:**
```{r eval=FALSE}
my_function <- function(x, y, data) {
  # Manual validation - verbose and inconsistent
  if (is.null(x)) stop("x cannot be NULL")
  if (!is.numeric(x)) stop("x must be numeric")
  if (any(is.na(x))) stop("x cannot contain NA")
  if (length(x) == 0) stop("x must have at least one element")
  
  if (is.null(y)) stop("y cannot be NULL")
  if (!is.character(y)) stop("y must be character")
  # ... more checks ...
}
```

**With bstatErr:**
```{r eval=FALSE}
my_function <- function(x, y, data) {
  # Clean, consistent validation
  check_numeric_vector(x)
  check_string(y)
  check_data_frame(data)
  
  # Your function logic here...
}
```

## Key Features

- ✅ Consistent API across all data types
- ✅ Informative error messages with function names
- ✅ Handles edge cases (NULL, NA, Inf, empty, etc.)
- ✅ Flexible options for different requirements
- ✅ Minimal performance overhead

---

# Basic Usage

## Validating Single Values

### Numeric Values

```{r}
# Valid numeric
check_numeric(3.14)

# Valid integer
check_numeric(42L)

# Allow NULL when needed
check_numeric(NULL, allow_null = TRUE)
```

```{r error=TRUE}
# These will fail
check_numeric("not a number")
check_numeric(NULL)
```

### Logical Values

```{r}
# Valid logical
check_logical(TRUE)
check_logical(FALSE)
```

```{r error=TRUE}
# These will fail
check_logical(1)  # Numeric, not logical
check_logical("TRUE")  # Character, not logical
```

### Character Strings

```{r}
# Valid strings
check_string("hello")
check_string("test message")
```

```{r error=TRUE}
# These will fail
check_string(123)  # Numeric, not string
check_string("")   # Empty string not allowed by default
```

---

# Validating Vectors

## Numeric Vectors

```{r}
# Valid numeric vectors
check_numeric_vector(c(1, 2, 3))
check_numeric_vector(1:10)
check_numeric_vector(seq(0, 1, 0.1))
```

### Handling NA Values

```{r error=TRUE}
# NA not allowed by default
check_numeric_vector(c(1, 2, NA, 4))
```

```{r}
# Allow NA when needed
check_numeric_vector(c(1, 2, NA, 4), allow_na = TRUE)
```

### Handling Infinite Values

```{r error=TRUE}
# Inf not allowed by default
check_numeric_vector(c(1, 2, Inf))
```

```{r}
# Allow Inf when needed
check_numeric_vector(c(1, Inf, -Inf), allow_inf = TRUE)
```

### Zero-Length Vectors

```{r error=TRUE}
# Empty vectors not allowed by default
check_numeric_vector(numeric(0))
```

```{r}
# Allow empty when needed
check_numeric_vector(numeric(0), allow_zero_length = TRUE)
```

## String Vectors

```{r}
# Valid string vectors
check_string_vector(c("a", "b", "c"))
check_string_vector(c("apple", "banana", "cherry"))
```

### Checking for Duplicates

```{r error=TRUE}
# Duplicates not allowed by default
check_string_vector(c("a", "b", "a"))
```

```{r}
# Allow duplicates when needed
check_string_vector(c("a", "b", "a"), allow_duplicates = TRUE)
```

### Requiring Names

```{r error=TRUE}
# Unnamed vectors fail when names required
check_string_vector(c("a", "b", "c"), must_have_names = TRUE)
```

```{r}
# Named vectors pass
check_string_vector(
  c(first = "a", second = "b", third = "c"),
  must_have_names = TRUE
)
```

---

# Validating Matrices and Data Frames

## Numeric Matrices

```{r}
# Valid matrices
m <- matrix(1:9, nrow = 3, ncol = 3)
check_numeric_matrix(m)
```

### Square Matrices

```{r}
# Require square matrix
m_square <- matrix(1:16, nrow = 4, ncol = 4)
check_numeric_matrix(m_square, must_be_square = TRUE)
```

```{r error=TRUE}
# Non-square fails
m_rect <- matrix(1:6, nrow = 2, ncol = 3)
check_numeric_matrix(m_rect, must_be_square = TRUE)
```

### Symmetric Matrices

```{r}
# Create symmetric matrix
m_sym <- matrix(c(1, 2, 3,
                  2, 4, 5,
                  3, 5, 6), nrow = 3, byrow = TRUE)

check_numeric_matrix(m_sym, must_be_symmetric = TRUE)
```

```{r error=TRUE}
# Non-symmetric fails
m_nonsym <- matrix(1:9, nrow = 3)
check_numeric_matrix(m_nonsym, must_be_symmetric = TRUE)
```

## Data Frames

```{r}
# Valid data frames
check_data_frame(mtcars)
check_data_frame(iris)
```

```{r error=TRUE}
# Empty data frames fail by default
empty_df <- data.frame()
check_data_frame(empty_df)
```

```{r}
# Allow empty when needed
check_data_frame(empty_df, allow_zero_rows = TRUE)
```

---

# Validating Objects

## Lists

```{r}
# Valid lists
check_list(list(a = 1, b = 2, c = 3))
check_list(list(1, 2, 3))  # Unnamed also OK by default
```

### Requiring Names

```{r error=TRUE}
# Unnamed fails when names required
check_list(list(1, 2, 3), must_have_names = TRUE)
```

```{r}
# Named passes
check_list(list(a = 1, b = 2, c = 3), must_have_names = TRUE)
```

## Functions

```{r}
# Valid functions
check_function(mean)
check_function(sum)

# User-defined functions
my_func <- function(x) x + 1
check_function(my_func)
```

```{r error=TRUE}
# Non-functions fail
check_function("mean")
check_function(42)
```

---

# Practical Examples

## Example 1: Statistical Function

```{r}
# Function to compute weighted mean
weighted_mean <- function(x, weights, na.rm = FALSE) {
  # Validate inputs
  check_numeric_vector(x)
  check_numeric_vector(weights)
  check_logical(na.rm)
  
  # Check lengths match
  if (length(x) != length(weights)) {
    stop("x and weights must have same length")
  }
  
  # Compute weighted mean
  if (na.rm) {
    valid <- !is.na(x) & !is.na(weights)
    x <- x[valid]
    weights <- weights[valid]
  }
  
  sum(x * weights) / sum(weights)
}

# Test it
weighted_mean(c(1, 2, 3, 4), c(0.1, 0.2, 0.3, 0.4))
```

```{r error=TRUE}
# Clear error messages
weighted_mean("not numeric", c(1, 2, 3))
weighted_mean(c(1, 2, 3), "not numeric")
```

## Example 2: Data Processing Function

```{r}
# Function to normalize data by group
normalize_by_group <- function(data, value_col, group_col) {
  # Validate inputs
  check_data_frame(data)
  check_string(value_col)
  check_string(group_col)
  
  # Check columns exist
  if (!value_col %in% names(data)) {
    stop("Column '", value_col, "' not found in data")
  }
  if (!group_col %in% names(data)) {
    stop("Column '", group_col, "' not found in data")
  }
  
  # Normalize by group
  data$normalized <- ave(
    data[[value_col]],
    data[[group_col]],
    FUN = function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
  )
  
  data
}

# Test it
test_data <- data.frame(
  value = c(1, 2, 3, 4, 5, 6),
  group = c("A", "A", "A", "B", "B", "B")
)

result <- normalize_by_group(test_data, "value", "group")
head(result)
```

## Example 3: Model Fitting Function

```{r}
# Simple linear regression wrapper
fit_linear_model <- function(formula, data, weights = NULL) {
  # Validate inputs
  check_data_frame(data)
  
  # Formula can be formula or string
  if (is.character(formula)) {
    formula <- as.formula(formula)
  }
  
  # Weights are optional
  if (!is.null(weights)) {
    check_numeric_vector(weights)
    if (length(weights) != nrow(data)) {
      stop("weights must have same length as data rows")
    }
  }
  
  # Fit model
  if (is.null(weights)) {
    lm(formula, data = data)
  } else {
    lm(formula, data = data, weights = weights)
  }
}

# Test it
model <- fit_linear_model(mpg ~ wt + hp, data = mtcars)
summary(model)
```

---

# Advanced Features

## Combining Validations

You can combine multiple validation requirements:

```{r}
# Allow NA and Inf, but require names
values <- c(a = 1, b = Inf, c = NA, d = 4)

check_numeric_vector(
  values,
  allow_na = TRUE,
  allow_inf = TRUE,
  must_have_names = TRUE
)
```

## Catching Conditions

The `catch_conditions()` utility captures errors, warnings, and messages:

```{r}
# Capture warning
result <- catch_conditions({
  x <- c(1, 2, NA)
  mean(x)  # Produces warning about NA
})

result$value  # The result
result$warning  # The warning object
```

```{r}
# Capture error with default value
result <- catch_conditions({
  stop("Something went wrong!")
}, default = NA)

result$value  # NA (the default)
result$error$message  # The error message
```

---

# Best Practices

## 1. Validate Early

Put validation at the start of your function:

```{r eval=FALSE}
my_function <- function(x, y, z) {
  # Validate FIRST
  check_numeric_vector(x)
  check_string(y)
  check_logical(z)
  
  # Then your logic
  # ...
}
```

## 2. Use Appropriate Checks

Choose the right validation function for your data type:

- Single values: `check_numeric()`, `check_logical()`, `check_string()`
- Vectors: `check_numeric_vector()`, `check_string_vector()`
- Matrices: `check_numeric_matrix()`
- Objects: `check_list()`, `check_data_frame()`, `check_function()`

## 3. Document Requirements

Make validation requirements clear in your documentation:

```{r eval=FALSE}
#' My Function
#'
#' @param x Numeric vector (no NA or Inf allowed)
#' @param y Character string (cannot be empty)
#' @param data Data frame (must have at least one row)
my_function <- function(x, y, data) {
  check_numeric_vector(x)  # Enforces: numeric, no NA, no Inf
  check_string(y)          # Enforces: character, not empty
  check_data_frame(data)   # Enforces: data.frame, has rows
  
  # ...
}
```

## 4. Allow Flexibility When Needed

Use `allow_*` parameters to provide flexibility:

```{r eval=FALSE}
# Function that can handle NA values
robust_mean <- function(x, na.rm = FALSE) {
  if (na.rm) {
    check_numeric_vector(x, allow_na = TRUE)
  } else {
    check_numeric_vector(x)
  }
  
  mean(x, na.rm = na.rm)
}
```

---

# Performance Considerations

Validation functions have minimal overhead:

```{r}
# Benchmark validation
x <- rnorm(1000)

system.time({
  for (i in 1:10000) {
    check_numeric_vector(x)
  }
})
```

Typical overhead is < 1 microsecond per call, negligible for most applications.

---

# Summary

The bstatErr package provides:

- ✅ **10 validation functions** for all common data types
- ✅ **Consistent API** with `allow_*` parameters
- ✅ **Informative errors** with function and argument names
- ✅ **Edge case handling** for NULL, NA, Inf, empty, etc.
- ✅ **Flexible options** for different requirements
- ✅ **Minimal overhead** for production use

Start using bstatErr today to make your R packages more robust!

---

# See Also

- `?bstatErr`: Package overview
- `?check_numeric_vector`: Numeric vector validation
- `?check_numeric_matrix`: Matrix validation
- `?catch_conditions`: Error and warning capture

For more information, visit the package repository or contact the maintainer.
